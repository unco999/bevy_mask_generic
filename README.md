# bevy_mask_generic
《mask泛型说明》公开也没事 你做好了分享我一份 

组件由掩码常量泛型做分类  同一个范畴（一个结构体）具有部分相同特征（有类似的操作）那么我们用特征注册这个泛型 比如  武器淬火::<铁质武器>::fn 武器摧毁::<铁质武器>::fn  怎么看待这个操作呢?(首先说明铁质武器是一个const const_t:u32 = 8之类的) 就是ECS很多特质

其实是一种书写化的特征抽取操作   比如武器淬火是一个操作  武器摧毁是一个操作 抽象的看 铁质武器是一种标签  甚至铁质和武器都可以做常量泛型的分类

而具体的执行 实际上是一种颗粒度的东西 在一种固定的输入下 我的输出是一定的 

那么MASK常量泛型解决了什么其他问题呢

1.MASK掩码具有详细的特征记录与计算优势 比如

0000001010101(这个1代表这个类型为铁质武器)

掩码可以很快知道是否是一个组合特征 

Struct 武器<const const_t:u32>

为什么要这样做呢

因为 你特征分类到位

其实武器不光有铁质

还有钢的成分对吧(原谅我粗糙的比喻)

 

那么我们初始化这个武器标签 应该是这样

Const 钢:u32 = 2   01 

Const 铁:u32 = 4 010 好像是这样

然后呢 我们再初始化武器

武器::<钢 + 铁>

这样就动态组合了这个武器的mask

现在武器的常量泛型mask是什么？

武器<110>

 

那么现在有一个系统来查询这个武器 我们可以最大程度上做到优化query的细粒度

也就是ECS的查询 我们只用 查询 

 fn ( query:Query(Entity,With(武器<钢>)) )

 fn ( query:Query(Entity,With(武器<钢 + 铁>)) )

 fn ( query:Query(Entity,With(武器<铁>)) )

这样是书写非常清晰的

 

再谈动态调度

根据上文所说到的 同样的输入 实际上只有一种输出

没有那么多分支 和 副作用

我的      武器摧毁::<铁质武器> 这种书写就说明了一切问题

不存在铁质武器会不是铁质武器  他永远是铁质武器

 

那么我在注册系统的时候 怎么办呢

比如 钢 + 铁的执行过程 难道我都要一个个写吗

非也

 

实际上我们写执行 应该细化到 怎么处理铁这个特质、怎么处理钢这个特质

随后我们这样注册系统

 

App().new()

.add_system( 武器摧毁<钢(常量) >::stream  )   //1

.add_system( 武器摧毁<钢(常量) + 铁(常量)>::srteam )  //2

.add_system( 武器摧毁<铁(常量) > ::stream ) //3

.run()

 

实际上以上3个系统

只有2个是核心 就是1和3

2是一个组合系统  他把2个粒子化的操作 串联起来运行了

不管是钢 还是铁 还是钢铁

反正查询到的实体 咱们要进行操作

共同的特征

我们要处理武器的元素 比如摧毁后

留下这个元素(钢)  给玩家一个元素钢 

在铁的标签里 留下这个元素铁

 

关键部分:

系统如何组合  你注册的   武器摧毁<钢(常量) + 铁(常量)>::srteam   的系统

 

因为我写的系统      只有 铁 和刚的  

那么这里就要进入mask计算

也就是说 只要是附加了2个特征的mask 我们最终都会返回到泛型的defualt输出函数

这也是我刚从gpt得知的 哈哈  也就是说 泛型的基础类里面的 defualt fn stream() 负责输出

基础类型 这时候检查二进制有  是110 那么明显是2个系统的组合

这个时候就输出 （010系统   100系统）绑定给注册系统

 

这个系统架构的优点：

1.清晰的书写方式

2.我们可以写大量 base 常量来区分不同的组件和实体

3.查询极大优化

4.不依赖结构体的内部数据  const 在编译期就做好了

 

如果你想探讨这个系统并且可以给出专业指导(我的泛型基础不太扎实 但是我对系统架构的直觉是可以的)

可以加我QQ1054093062
